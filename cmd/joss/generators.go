package main

import (
	"database/sql"
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"

	"time"

	_ "github.com/go-sql-driver/mysql"
	_ "modernc.org/sqlite"
)

// Helper to check if project is console-only
func isConsoleProject() bool {
	if _, err := os.Stat("app/views"); os.IsNotExist(err) {
		return true
	}
	return false
}

func createController(name string) {
	path := filepath.Join("app", "controllers", name+".joss")
	os.MkdirAll(filepath.Dir(path), 0755)

	var content string
	if isConsoleProject() {
		content = fmt.Sprintf(`class %s {
    function index() {
        print("Hello from %s")
    }
}`, name, name)
	} else {
		content = fmt.Sprintf(`class %s {
    function index() {
        return View.render("%s/index")
    }
}`, name, strings.ToLower(name))
	}

	writeGenFile(path, content)
}

func createModel(name string) {
	path := filepath.Join("app", "models", name+".joss")
	os.MkdirAll(filepath.Dir(path), 0755)

	tableName := "js_" + strings.ToLower(pluralize(name)) // Plural convention

	content := fmt.Sprintf(`class %s extends GranDB {
    function constructor() {
        $this.tabla = "%s"
    }
}`, name, tableName)

	writeGenFile(path, content)
}

func createView(name string) {
	if isConsoleProject() {
		fmt.Println("Error: Cannot create view in a console project.")
		return
	}

	// name can be "users/index"
	path := filepath.Join("app", "views", name+".joss.html")
	if !strings.HasSuffix(name, ".joss.html") && !strings.HasSuffix(name, ".html") {
		// If no extension, assume .joss.html
	} else {
		// If extension provided, use it
		path = filepath.Join("app", "views", name)
	}

	os.MkdirAll(filepath.Dir(path), 0755)

	content := fmt.Sprintf(`@extends('layouts.app')

@section('content')
    <h1>View: %s</h1>
    <p>Generated by joss make:view</p>
@endsection
`, name)

	writeGenFile(path, content)
}

func createMVC(name string) {
	fmt.Printf("Generating MVC for %s...\n", name)
	createModel(name)
	createController(name + "Controller")
	if !isConsoleProject() {
		createView(strings.ToLower(name) + "/index")
	}
}

// CRUD Generator
type ColumnSchema struct {
	Name string
	Type string
}

func createCRUD(tableName string) {
	fmt.Printf("Generating CRUD for table '%s'...\n", tableName)

	// 1. Connect to DB
	dbType, dbPath, dbHost, dbUser, dbPass, dbName := loadEnvConfig()

	var db *sql.DB
	var err error

	if dbType == "sqlite" {
		db, err = sql.Open("sqlite", dbPath)
	} else {
		dsn := fmt.Sprintf("%s:%s@tcp(%s)/%s", dbUser, dbPass, dbHost, dbName)
		db, err = sql.Open("mysql", dsn)
	}

	if err != nil {
		fmt.Printf("Error connecting to DB: %v\n", err)
		return
	}
	defer db.Close()

	// 2. Inspect Schema
	cols, err := getColumns(db, dbType, tableName)
	if err != nil {
		fmt.Printf("Error inspecting table: %v\n", err)
		return
	}

	if len(cols) == 0 {
		fmt.Printf("Table '%s' not found or empty.\n", tableName)
	}
	// 3. Analyze Relations
	var relations []Relation
	for _, c := range cols {
		fmt.Printf("Inspecting column: '%s'\n", c.Name)
		if strings.HasSuffix(c.Name, "_id") {
			fmt.Printf("  -> Found relation for %s\n", c.Name)
			// Infer relation
			baseName := strings.TrimSuffix(c.Name, "_id")
			relatedTable := "js_" + strings.ToLower(pluralize(baseName)) // Convention: js_users

			// Smartly detect display column
			displayCol := getDisplayColumn(db, dbType, relatedTable)
			fmt.Printf("  -> Detected display column for %s: %s\n", relatedTable, displayCol)

			relations = append(relations, Relation{
				ForeignKey: c.Name,
				Table:      relatedTable,
				Alias:      baseName + "_" + displayCol, // e.g. user_username
				DisplayCol: displayCol,
			})
		}
	}
	fmt.Printf("Total relations found: %d\n", len(relations))

	// 4. Generate Artifacts
	// Model
	modelName := snakeToCamel(tableName)
	if strings.HasPrefix(modelName, "Js") {
		modelName = modelName[2:]
	}
	// Use singularize helper
	modelName = singularize(modelName)

	// Model
	createModel(modelName)

	// Auto-create related models
	for _, rel := range relations {
		relModelName := snakeToCamel(rel.Table)
		if strings.HasPrefix(relModelName, "Js") {
			relModelName = relModelName[2:]
		}
		relModelName = singularize(relModelName)

		path := filepath.Join("app", "models", relModelName+".joss")
		if _, err := os.Stat(path); os.IsNotExist(err) {
			fmt.Printf("Auto-creating missing related model: %s\n", relModelName)
			createModel(relModelName)
		}
	}

	// Controller
	createCRUDController(modelName, tableName, cols, relations)

	// Views
	if !isConsoleProject() {
		createCRUDViews(modelName, cols, relations)
		updateNavbar(modelName)
		injectProtectedRoutes(modelName)
	}
}

type Relation struct {
	ForeignKey string // user_id
	Table      string // js_users
	Alias      string // user_name
	DisplayCol string // name
}

func createCRUDController(modelName, tableName string, cols []ColumnSchema, relations []Relation) {
	path := filepath.Join("app", "controllers", modelName+"Controller.joss")
	os.MkdirAll(filepath.Dir(path), 0755)

	viewPrefix := strings.ToLower(modelName)

	// Build Index Query with Joins - Use single line to avoid parser issues
	indexLogic := fmt.Sprintf("$%s = new %s()", strings.ToLower(modelName), modelName)

	if len(relations) > 0 {
		indexLogic += fmt.Sprintf("\n        $data = $%s", strings.ToLower(modelName))
		// Selects
		selects := []string{fmt.Sprintf("%s.*", tableName)}
		for _, rel := range relations {
			selects = append(selects, fmt.Sprintf("%s.%s as %s", rel.Table, rel.DisplayCol, rel.Alias))
		}
		indexLogic += fmt.Sprintf(".select([\"%s\"])", strings.Join(selects, "\", \""))

		// Joins
		for _, rel := range relations {
			indexLogic += fmt.Sprintf(".leftJoin(\"%s\", \"%s.%s\", \"=\", \"%s.id\")", rel.Table, tableName, rel.ForeignKey, rel.Table)
		}
		indexLogic += ".get()"
	} else {
		indexLogic += fmt.Sprintf("\n        $data = $%s.get()", strings.ToLower(modelName))
	}

	// Build Create Logic (Fetch relations)
	createLogic := ""
	createVars := ""
	if len(relations) > 0 {
		for _, rel := range relations {
			// Derive model name from table: js_roles -> Role
			relModel := snakeToCamel(rel.Table)
			if strings.HasPrefix(relModel, "Js") {
				relModel = relModel[2:]
			}
			relModel = singularize(relModel)
			varName := strings.ToLower(pluralize(relModel)) // roles
			createLogic += fmt.Sprintf("\n        $%sModel = new %s()", strings.ToLower(relModel), relModel)
			createLogic += fmt.Sprintf("\n        $%s = $%sModel.get()", varName, strings.ToLower(relModel))
			createVars += fmt.Sprintf(", \"%s\": $%s", varName, varName)
		}
	}

	content := fmt.Sprintf(`class %sController {
    
    function index() {
        %s
        return View.render("%s/index", {"items": $data})
    }

    function create() {
        %s
        return View.render("%s/create", {%s})
    }

    function store() {
        $req = new Request()
        $data = $req.except(["_token", "_referer", "_method"])
        
        $model = new %s()
        $model.insert($data)
        
        return redirect("/%s")
    }

    function edit($id) {
        $model = new %s()
        $item = $model.where("id", $id).first()
        %s
        return View.render("%s/edit", {"item": $item%s})
    }

    function update($id) {
        $req = new Request()
        $data = $req.except(["_token", "_referer", "_method"])
        
        $model = new %s()
        $model.where("id", $id).update($data)
        
        return redirect("/%s")
    }

    function delete($id) {
        $model = new %s()
        $model.where("id", $id).delete()
        return redirect("/%s")
    }
}`, modelName, indexLogic, viewPrefix, createLogic, viewPrefix, strings.TrimPrefix(createVars, ", "), modelName, viewPrefix, modelName, createLogic, viewPrefix, createVars, modelName, viewPrefix, modelName, viewPrefix)

	writeGenFile(path, content)
}

func createCRUDViews(modelName string, cols []ColumnSchema, relations []Relation) {
	folder := filepath.Join("app", "views", strings.ToLower(modelName))
	os.MkdirAll(folder, 0755)

	// Index
	indexHtml := fmt.Sprintf(`@extends('layouts.master')

@section('content')
<div class="card">
    <div class="card-header d-flex justify-content-between align-items-center">
        <h2>%s List</h2>
        <a href="/%s/create" class="btn btn-primary"><i class="fas fa-plus"></i> Create New</a>
    </div>
    <div class="card-body p-0">
        <div class="table-responsive">
            <table class="table table-hover mb-0">
                <thead>
                    <tr>
`, modelName, strings.ToLower(modelName))

	for _, c := range cols {
		headerName := c.Name
		for _, rel := range relations {
			if c.Name == rel.ForeignKey {
				headerName = strings.Title(strings.Replace(rel.Alias, "_", " ", -1))
				break
			}
		}
		indexHtml += fmt.Sprintf("                        <th>%s</th>\n", headerName)
	}
	indexHtml += `                        <th class="text-end">Actions</th>
                    </tr>
                </thead>
                <tbody>
                    @foreach($items as $item)
                    <tr>
`
	for _, c := range cols {
		val := fmt.Sprintf("{{ $item.%s }}", c.Name)
		for _, rel := range relations {
			if c.Name == rel.ForeignKey {
				val = fmt.Sprintf("{{ $item.%s }}", rel.Alias)
				break
			}
		}
		indexHtml += fmt.Sprintf("                        <td>%s</td>\n", val)
	}
	indexHtml += fmt.Sprintf(`                        <td class="text-end">
                            <a href="/%s/edit/{{ $item.id }}" class="btn btn-sm btn-outline-info"><i class="fas fa-edit"></i></a>
                            <a href="/%s/delete/{{ $item.id }}" class="btn btn-sm btn-outline-danger" onclick="return confirm('Are you sure?')"><i class="fas fa-trash"></i></a>
                        </td>
                    </tr>
                    @endforeach
                </tbody>
            </table>
        </div>
    </div>
</div>
@endsection
`, strings.ToLower(modelName), strings.ToLower(modelName))

	writeGenFile(filepath.Join(folder, "index.joss.html"), indexHtml)

	// Create
	createHtml := fmt.Sprintf(`@extends('layouts.master')

@section('content')
<div class="row justify-content-center">
    <div class="col-md-8">
        <div class="card">
            <div class="card-header">
                <h2>Create %s</h2>
            </div>
            <div class="card-body">
                <form action="/%s/store" method="POST">
                    {{ csrf_field() }}
`, modelName, strings.ToLower(modelName))

	for _, c := range cols {
		if c.Name == "id" || c.Name == "created_at" || c.Name == "updated_at" {
			continue
		}

		// Check for relation
		isRelation := false
		var relData Relation
		for _, rel := range relations {
			if c.Name == rel.ForeignKey {
				isRelation = true
				relData = rel
				break
			}
		}

		if isRelation {
			// Derive variable name: js_roles -> roles
			relModel := snakeToCamel(relData.Table)
			if strings.HasPrefix(relModel, "Js") {
				relModel = relModel[2:]
			}
			relModel = singularize(relModel)
			varName := strings.ToLower(pluralize(relModel))

			createHtml += fmt.Sprintf(`                    <div class="form-group">
                        <label>%s</label>
                        <select name="%s" class="form-control">
                            <option value="">Select %s</option>
                            @foreach($%s as $opt)
                            <option value="{{ $opt.id }}">{{ $opt.%s }}</option>
                            @endforeach
                        </select>
                    </div>
`, strings.Title(strings.Replace(c.Name, "_", " ", -1)), c.Name, relModel, varName, relData.DisplayCol)
		} else {
			createHtml += fmt.Sprintf(`                    <div class="form-group">
                        <label>%s</label>
                        <input type="text" name="%s" class="form-control">
                    </div>
`, c.Name, c.Name)
		}
	}
	createHtml += `                    <div class="d-flex justify-content-end gap-2">
                        <a href="/` + strings.ToLower(modelName) + `" class="btn btn-outline-secondary">Cancel</a>
                        <button type="submit" class="btn btn-primary">Save Record</button>
                    </div>
                </form>
            </div>
        </div>
    </div>
</div>
@endsection
`
	writeGenFile(filepath.Join(folder, "create.joss.html"), createHtml)

	// Edit
	editHtml := fmt.Sprintf(`@extends('layouts.master')

@section('content')
<div class="row justify-content-center">
    <div class="col-md-8">
        <div class="card">
            <div class="card-header">
                <h2>Edit %s</h2>
            </div>
            <div class="card-body">
                <form action="/%s/update/{{ $item.id }}" method="POST">
                    {{ csrf_field() }}
`, modelName, strings.ToLower(modelName))

	for _, c := range cols {
		if c.Name == "id" || c.Name == "created_at" || c.Name == "updated_at" {
			continue
		}

		// Check for relation
		isRelation := false
		var relData Relation
		for _, rel := range relations {
			if c.Name == rel.ForeignKey {
				isRelation = true
				relData = rel
				break
			}
		}

		if isRelation {
			// Derive variable name: js_roles -> roles
			relModel := snakeToCamel(relData.Table)
			if strings.HasPrefix(relModel, "Js") {
				relModel = relModel[2:]
			}
			relModel = singularize(relModel)
			varName := strings.ToLower(pluralize(relModel))

			editHtml += fmt.Sprintf(`                    <div class="form-group">
                        <label>%s</label>
                        <select name="%s" class="form-control">
                            <option value="">Select %s</option>
                            @foreach($%s as $opt)
                            <option value="{{ $opt.id }}" {{ $item.%s == $opt.id ? 'selected' : '' }}>{{ $opt.%s }}</option>
                            @endforeach
                        </select>
                    </div>
`, strings.Title(strings.Replace(c.Name, "_", " ", -1)), c.Name, relModel, varName, c.Name, relData.DisplayCol)
		} else {
			editHtml += fmt.Sprintf(`                    <div class="form-group">
                        <label>%s</label>
                        <input type="text" name="%s" class="form-control" value="{{ $item.%s }}">
                    </div>
`, c.Name, c.Name, c.Name)
		}
	}
	editHtml += `                    <div class="d-flex justify-content-end gap-2">
                        <a href="/` + strings.ToLower(modelName) + `" class="btn btn-outline-secondary">Cancel</a>
                        <button type="submit" class="btn btn-primary">Update Record</button>
                    </div>
                </form>
            </div>
        </div>
    </div>
</div>
@endsection
`
	writeGenFile(filepath.Join(folder, "edit.joss.html"), editHtml)
}

func getColumns(db *sql.DB, dbType, tableName string) ([]ColumnSchema, error) {
	var cols []ColumnSchema

	if dbType == "sqlite" {
		rows, err := db.Query(fmt.Sprintf("PRAGMA table_info(%s)", tableName))
		if err != nil {
			return nil, err
		}
		defer rows.Close()

		for rows.Next() {
			var cid int
			var name, ctype string
			var notnull, pk int
			var dflt interface{}
			rows.Scan(&cid, &name, &ctype, &notnull, &dflt, &pk)
			cols = append(cols, ColumnSchema{Name: name, Type: ctype})
		}
	} else {
		rows, err := db.Query(fmt.Sprintf("DESCRIBE %s", tableName))
		if err != nil {
			return nil, err
		}
		defer rows.Close()

		for rows.Next() {
			var field, ctype, null, key string
			var extra interface{}
			var def interface{}
			rows.Scan(&field, &ctype, &null, &key, &def, &extra)
			cols = append(cols, ColumnSchema{Name: field, Type: ctype})
		}
	}
	return cols, nil
}

func loadEnvConfig() (string, string, string, string, string, string) {
	// Simple parser for env.joss
	content, _ := ioutil.ReadFile("env.joss")
	lines := strings.Split(string(content), "\n")

	config := make(map[string]string)
	for _, line := range lines {
		parts := strings.SplitN(line, "=", 2)
		if len(parts) == 2 {
			key := strings.TrimSpace(parts[0])
			val := strings.Trim(strings.TrimSpace(parts[1]), "\"")
			config[key] = val
		}
	}
	return config["DB"], config["DB_PATH"], config["DB_HOST"], config["DB_USER"], config["DB_PASS"], config["DB_NAME"]
}

func updateNavbar(modelName string) {
	// Try to find layouts/master.joss.html
	path := filepath.Join("app", "views", "layouts", "master.joss.html")
	content, err := ioutil.ReadFile(path)
	if err == nil {
		html := string(content)
		link := fmt.Sprintf(`<li><a href="/%s"><i class="fas fa-circle"></i> %s</a></li>`, strings.ToLower(modelName), modelName)

		// Insert before <!-- Injected Links Here -->
		if strings.Contains(html, "<!-- Injected Links Here -->") {
			html = strings.Replace(html, "<!-- Injected Links Here -->", link+"\n                        <!-- Injected Links Here -->", 1)
			ioutil.WriteFile(path, []byte(html), 0644)
			fmt.Println("Updated navbar in layouts/master.joss.html")
		}
	}
}

func injectProtectedRoutes(modelName string) {
	path := "routes.joss"
	content, err := ioutil.ReadFile(path)
	if err != nil {
		return
	}

	routes := fmt.Sprintf(`
    // CRUD Routes for %s
    Router.get("/%s", "%sController@index")
    Router.get("/%s/create", "%sController@create")
    Router.post("/%s/store", "%sController@store")
    Router.get("/%s/edit/{id}", "%sController@edit")
    Router.post("/%s/update/{id}", "%sController@update")
    Router.get("/%s/delete/{id}", "%sController@delete")
`, modelName,
		strings.ToLower(modelName), modelName,
		strings.ToLower(modelName), modelName,
		strings.ToLower(modelName), modelName,
		strings.ToLower(modelName), modelName,
		strings.ToLower(modelName), modelName,
		strings.ToLower(modelName), modelName)

	strContent := string(content)

	// Check if "auth" group exists
	if strings.Contains(strContent, `Router.group("auth"`) {
		// Inject inside group
		// Find the closing brace of the group? This is hard with regex.
		// Simple approach: Find `Router.group("auth", function() {` and append after it.

		target := `Router.group("auth", function() {`
		if strings.Contains(strContent, target) {
			strContent = strings.Replace(strContent, target, target+routes, 1)
			ioutil.WriteFile(path, []byte(strContent), 0644)
			fmt.Println("Injected protected routes into 'auth' group.")
			return
		}
	}

	// If no group, append to end (unprotected for now, or wrap)
	// Let's create the group if it doesn't exist?
	// Or just append.

	// Better: Append a new protected group
	newGroup := fmt.Sprintf(`
Router.group("auth", function() {%s})
`, routes)

	ioutil.WriteFile(path, []byte(strContent+newGroup), 0644)
	fmt.Println("Created new 'auth' group with routes.")
}

func writeGenFile(path, content string) {
	err := ioutil.WriteFile(path, []byte(content), 0644)
	if err != nil {
		fmt.Printf("Error creating file %s: %v\n", path, err)
	} else {
		fmt.Printf("Created: %s\n", path)
	}
}

func snakeToCamel(s string) string {
	parts := strings.Split(s, "_")
	var res string
	for _, p := range parts {
		if len(p) > 0 {
			res += strings.ToUpper(p[:1]) + p[1:]
		}
	}
	return res
}

func createMigration(name string) {
	timestamp := time.Now().Format("20060102150405")
	filename := fmt.Sprintf("%s_%s.joss", timestamp, name)
	path := filepath.Join("app", "database", "migrations", filename)
	os.MkdirAll(filepath.Dir(path), 0755)

	content := fmt.Sprintf(`// Migration: %s
// Created at: %s

Schema.create("%s", function($table) {
    $table.id()
    $table.string("name")
    $table.timestamps()
})
`, name, time.Now().Format("2006-01-02 15:04:05"), name)

	writeGenFile(path, content)
}

func getDisplayColumn(db *sql.DB, dbType, tableName string) string {
	cols, err := getColumns(db, dbType, tableName)
	if err != nil {
		return "id"
	}

	candidates := []string{"name", "title", "username", "email", "first_name", "last_name", "description", "slug", "code"}

	for _, candidate := range candidates {
		for _, col := range cols {
			if col.Name == candidate {
				return candidate
			}
		}
	}

	// If no candidate found, look for any string column
	for _, col := range cols {
		lowerType := strings.ToLower(col.Type)
		if strings.Contains(lowerType, "char") || strings.Contains(lowerType, "text") {
			return col.Name
		}
	}

	return "id"
}

func removeCRUD(tableName string) {
	fmt.Printf("Removing CRUD for table '%s'...\n", tableName)

	// 1. Infer Model Name
	modelName := snakeToCamel(tableName)
	if strings.HasPrefix(modelName, "Js") {
		modelName = modelName[2:]
	}
	modelName = singularize(modelName)

	fmt.Printf("Inferred Model Name: %s\n", modelName)

	// 2. Delete Controller
	controllerPath := filepath.Join("app", "controllers", modelName+"Controller.joss")
	if _, err := os.Stat(controllerPath); err == nil {
		os.Remove(controllerPath)
		fmt.Printf("Deleted: %s\n", controllerPath)
	}

	// 3. Delete Model
	modelPath := filepath.Join("app", "models", modelName+".joss")
	if _, err := os.Stat(modelPath); err == nil {
		os.Remove(modelPath)
		fmt.Printf("Deleted: %s\n", modelPath)
	}

	// 4. Delete Views
	viewsPath := filepath.Join("app", "views", strings.ToLower(modelName))
	if _, err := os.Stat(viewsPath); err == nil {
		os.RemoveAll(viewsPath)
		fmt.Printf("Deleted: %s\n", viewsPath)
	}

	// 5. Remove Routes
	routesPath := "routes.joss"
	content, err := ioutil.ReadFile(routesPath)
	if err == nil {
		lines := strings.Split(string(content), "\n")
		var newLines []string
		for _, line := range lines {
			// Check for CRUD Routes comment
			if strings.Contains(line, fmt.Sprintf("// CRUD Routes for %s", modelName)) {
				continue
			}
			// Filter out lines that contain the controller name
			if strings.Contains(line, modelName+"Controller") {
				continue
			}
			newLines = append(newLines, line)
		}
		ioutil.WriteFile(routesPath, []byte(strings.Join(newLines, "\n")), 0644)
		fmt.Println("Cleaned routes.")
	}

	// 6. Remove Navbar Link
	masterPath := filepath.Join("app", "views", "layouts", "master.joss.html")
	content, err = ioutil.ReadFile(masterPath)
	if err == nil {
		lines := strings.Split(string(content), "\n")
		var newLines []string
		linkTarget := fmt.Sprintf(`href="/%s"`, strings.ToLower(modelName))
		for _, line := range lines {
			if strings.Contains(line, linkTarget) {
				continue
			}
			newLines = append(newLines, line)
		}
		ioutil.WriteFile(masterPath, []byte(strings.Join(newLines, "\n")), 0644)
		fmt.Println("Cleaned navbar.")
	}

	fmt.Println("CRUD removal complete.")
}
